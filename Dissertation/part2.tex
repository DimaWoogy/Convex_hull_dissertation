\chapter{Разработка и формализация нового алгоритма построения выпуклой оболочки} \label{chapt2}

\section{Формализация понятия выпуклой оболочки} \label{sect2_1}

Пусть дано множество $S$ точек. Выпуклой оболочкой данного множества называется наименьшее выпуклое множество, содержащее $S$. Формально выпуклая оболочка может быть определена как пересечение всех выпуклых множеств, которые содержат $S$.

Это определение является самым популярным и общим, но оно слишком далеко от практики, поэтому мы будем использовать другое. Заметим, что определение, приведённое далее, работает только для случая двумерного пространства.

Для того, что формализовать понятие выпуклой оболочке нам снова приходит на помощь предикат $ccw$, описанный в формуле \ref{eq:ccw}. Выпуклой оболочкой множества $S$ будет называться выпуклый многоугольник $T$ с вершинами $t_i \in S$, пронумерованными против часовой стрелки для $i = 1,...,n$. Причём обязательно выполнения условия \ref{eq:convex_hull_def}.

\begin{equation}\label{eq:convex_hull_def}
\forall [t_i, t_{i+1}] \in T, p \in S \backslash \{ t_i, t_{i+1} \} : ccw(t_i, t_{i+1}, p)
\end{equation}

Это выражение утверждает, что каждая точка $p \in S$ кроме текущего ребра $t_i, t_{i+1}]$ находится слева от него. Это свойство выпуклой оболочки отлично показано на рисунке \ref{img:convex_hull_def} с помощью ориентированных рёбер.

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[Конечное множество точек $S$\label{img:convex_hull_def_1}]{%
			\includegraphics[width=0.4\linewidth]{convex_hull_def_1}}
		\hfill
		\subbottom[Выпуклая оболочка с ориентированными рёбрами\label{img:convex_hull_def_2}]{%
			\includegraphics[width=0.4\linewidth]{convex_hull_def_2}}
		\hfill
	}
	\caption{Формализация понятия выпуклой оболочки}
	\label{img:convex_hull_def}
\end{figure}

Заметим, что это определение никак не нарушает требование минимальности выбранного многоугольника, так как мы составляем выпуклую оболочку из точек, которые принадлежат множеству $S$.

\section{Описание алгоритма основанного на использовании бинарного дерева} \label{sect2_2}

\subsection{Основная идея} \label{subsect2_2_1}

Основная идея предлагаемого алгоритма очень похожа на принцип, лежащий в основе инкрементального алгоритма. Мы можем хранить точки в сбалансированном по высоте двоичном дереве поиска. Главное различие с инкрементальным алгоритмом - точки будут храниться в одном дереве, где точки будут расположены по углу относительно центра выпуклой оболочки.

Чтобы объяснить работу алгоритма нам понадобится уже известный нам предикат $ccw$, определённый в формуле \ref{eq:ccw}. Также необходимо определить понятие экстремальной точки. Экстремальная точка множества $S$ - это точка, которая точно принадлежит выпуклой оболочке $S$.

Пусть дано множество точек $S$ и необходимо найти выпуклую оболочку данного множества.

Первый шаг алгоритма - это нахождение приближенного центра, с помощью которого будут отсортированы в дереве точки. Это можно сделать посчитав среднее арифметическое трёх экстремальных точек. Это отличная аппроксимация центра для наших целей. Первые 2 экстремальные точки -  это самая левая $A$ и правая $B$ точки множества $S$. Третья точка - это наиболее удалённая от линии $A, B$ точка $C$.

Пример таких точек показан на рисунке \ref{img:my_extreme_points}. Точка $D$ - это приближённый центр выпуклой оболочки, который мы искали.

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_extreme_points_1}]{%
			\includegraphics[width=0.4\linewidth]{my_extreme_points_1}}
		\hfill
		\subbottom[\label{img:my_extreme_points_2}]{%
			\includegraphics[width=0.4\linewidth]{my_extreme_points_2}}
		\hfill
	}
	\caption{Нахождение приближённого центра выпуклой оболочки}
	\label{img:my_extreme_points}
\end{figure}

После нахождения центра мы добавляем точки $A, B, C$ в наше дерево поиска. Остальные точки будут добавлены в случайном порядке.

Пусть мы уже построили дерево поиска, в котором содержится наша выпуклая оболочка, отсортированная по углу относительно центра $D$, найденного ранее. Теперь необходимо добавить новую точку $A$.

Первое, что необходимо найти - это две точки $L$ и $R$. Точки $L$, $R$ - это точки слева и справа соответственно от $A$ по углу относительно центра $D$.

%TODO: Проверить, что я точно написал правду для точек на одной прямой

После чего может быть 2 случая. Если $ccw(L, R, A)$ не выполняется, то новая точка $A$ не должна быть частью выпуклой оболочки и может быть пропущена. Этот случай показан на рисунке \ref{img:my_point_cases_1}. Иначе точки должна быть частью выпуклой оболочки и мы продолжим добавлять её. Это показано на рисунке \ref{img:my_point_cases_2}.

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_point_cases_1}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_1}}
		\hfill
		\subbottom[\label{img:my_point_cases_2}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_2}}
		\hfill
	}
	\caption{Добавление новой точки в выпуклую оболочку}
	\label{img:my_point_cases}
\end{figure}

Итак, мы определили, что точка $A$ должна быть на выпуклой оболочке. Теперь необходимо удалить точки, которые будут внутри оболочки после добавления точки $A$. Это делается с помощью итерации по точкам вправо (аналогичный алгоритм должен быть выполнен для левой стороны) от новой точки. Чтобы определить должна ли точка быть удалена или нет мы будем использовать подход, похожий на тот, который используется в алгоритме Грэхема. Каждые два смежных ребра выпуклой оболочки должны лежать против часовой стрелки.

Пусть следующая точка, которая рассматривается на удаление - это $B$, а точка следующая после неё $C$. Как сказано выше каждые два смежных ребра должны лежать против часовой стрелки. Это очень легко проверить с помощью предиката $ccw$. Если $ccw(C, B, A)$ тогда $B$ не должна быть удалена и мы должны прекратить удаление точек в эту сторону, потому что все точки после $B$ уже удовлетворяют условию выпуклой оболочки. Иначе мы должны удалить точку $B$ и рассмотреть точку $C$ как следующую. Этот процесс показан на рисунках \ref{img:my_points_deletion_1} и \ref{img:my_points_deletion_2}.

На рисунках \ref{img:my_points_deletion_1_1} и \ref{img:my_points_deletion_1_2} можно видеть, что точки $C, B, A$ лежат по часовой стрелке, поэтому точка $B$ должна быть удалена из выпуклой оболочки. Рисунок \ref{img:my_points_deletion_2_1} демонстрирует, что мы должна прекратить удаление точек справа от новой точки, так как $C, B, A$ теперь формирует тройку, которая лежит против часовой стрелки. Аналогично удаление не нужно производить слева от точки, что показано на рисунке \ref{img:my_points_deletion_2_2}. Действительно, на рисунках видно, что в конце получилась готовая выпуклая оболочка добавленных на текущий момент точек.

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_points_deletion_1_1}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_3}}
		\hfill
		\subbottom[\label{img:my_points_deletion_1_2}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_4}}
		\hfill
	}
	\caption{Удаление точек, которые оказались внутри выпуклой оболочки}
	\label{img:my_points_deletion_1}
\end{figure}

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_points_deletion_2_1}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_5}}
		\hfill
		\subbottom[\label{img:my_points_deletion_2_2}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_6}}
		\hfill
	}
	\caption{Критерий завершения удаления точек}
	\label{img:my_points_deletion_2}
\end{figure}

Как видно этот процесс очень схож с процессом добавления точек в инкрементальном алгоритме. Различия небольшие, но они позволяют быстрее добавлять точки в выпуклую оболочку.

Блок-схема всего алгоритма показана на рисунках \ref{img:my_algo} и \ref{img:my_algo_deletion}.

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{my_algo}
	\caption{Блок-схема работы предлагаемого алгоритма}
	\label{img:my_algo}
\end{figure}

\begin{figure}[H]
	\centering
	\includegraphics[scale=0.8]{my_algo_2}
	\caption{Блок-схема функции удаления точек перед добавлением точки point}
	\label{img:my_algo_deletion}
\end{figure}

\subsection{Детали реализации} \label{subsect2_2_2}

Первая важная деталь, которая упрощает реализацию нашего алгоритма - это конечно преобразование точек при работе алгоритма. Намного удобнее работать считать, что приближённый центр $D$, получение которого описывалось в предыдущей главе - это точка $0, 0)$. Как показано в \ref{eq:ccw} мы вычисляем $ccw$ через $det$, а вычислять $det(A, B, D)$ легче, если $D_x = 0$ и $D_y = 0$. Также нельзя забывать про конечную цель вычисления выпуклой оболочки. Для вычисления дескриптора опять намного удобнее пользоваться координатами уже переведёнными в центр объекта, так как на дескриптор никак не должно влиять положения объекта на изображении.

Вторая деталь, которая также важна при реализации - это углы относительно центра, про которые мы так много говорили. Вычисление углов через тригонометрические операции - это очень долго, и в этом случае наш алгоритм не смог бы конкурировать по производительности с самыми популярными алгоритмами вычисления выпуклой оболочки.

Необходимо придумать предикат, который бы определял положение точек в дереве, которое хранит текущую выпуклую оболочку. Первой попыткой придумать такой предикат будет использование предиката $ccw$, как это показано в \ref{eq:my_ccw_predicate}.

\begin{equation}\label{eq:my_ccw_predicate}
A<B=ccw(A, B, (0, 0))
\end{equation}

Заметим, что можно использовать точку $(0, 0)$ как центр, так как точки $A, B$ уже преобразованы в новую систему координат.

%TODO: перевести strict weak ordering и добавить ссылку на стандарт c++
К сожалению, такой предикат не соответствует strict weak ordering, потому что не выполняется транзитивность. Как можно видеть на рисунке \ref{img:non_transitivity_1} выполняется $ccw(A, B, D)$, поэтому $A$ меньше $B$. При этом выполняется $ccw(B, C, D)$, поэтому $B$ меньше $C$. Но на рисунке \ref{img:non_transitivity_2} в это еже время показано, что не выполняется $ccw(A, C, D)$, то есть $A$ не меньше $C$. В итоге имеем $A < B < C <= A$, что, очевидно, неверно.

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:non_transitivity_1}]{%
			\includegraphics[width=0.4\linewidth]{non_transitivity_1}}
		\hfill
		\subbottom[\label{img:non_transitivity_2}]{%
			\includegraphics[width=0.4\linewidth]{non_transitivity_2}}
		\hfill
	}
	\caption{Нетранзитивный предикат}
	\label{img:non_transitivity}
\end{figure}

Итак, необходимо сделать такую функцию, которая принимает точки $A$ и $B$ и возвращает $true$, если $A$ меньше $B$, иначе возвращает $false$. Эта функция будет использована в сбалансированном дереве поиска как компаратор. Был использован следующий алгоритм:

\begin{algorithm}[H]
	\caption{BSTPredicate - компаратор для сравнения точек}
	\label{alg:bst_predicate}
	\begin{algorithmic}[1]
		\Procedure{BSTPredicate}{$A, B$}
		\State $leftUp \gets 0<y_A$
		\State $rightUp \gets 0<y_B$
		\If {$leftUp \neq rightUp$}
			\Return $leftUp < rightUp$
		\EndIf
		\If {$(y_A=0) \& (y_B=0)$}
			\Return $(0<x_A) < (0<x_B)$
		\EndIf
		\Return $ccw(A, B, (0, 0))$
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Эта несложная функция реализует корректный для сортировки предикат. Для этого изначально она делит всю плоскость координат на две части: верхнюю и нижнюю. Если точки, которые мы сравниваем лежат на разных сторонах, тогда точка, которая ниже - меньше. Иначе мы должны расммотреть граничный случай, когда обе точки находятся на оси $y$. После чего мы уверены, что точки находятся в одно полуплоскости, что даёт основание просто использовать предикат $ccw$ для определения порядка.

Пример порядка точек, вычисленного, с помощью алгоритма BSTPredicate показан на рисунке \ref{img:BSTPred_ordering}.

\begin{figure}[H]
	\centering
	\includegraphics{BSTPred_ordering}
	\caption{Сортировка точек предикатом BSTPredicate}
	\label{img:BSTPred_ordering}
\end{figure}

\section{Доказательство корректности работы алгоритма} \label{subsect2_3}

Доказательство корректности работы алгоритма удобнее всего построить с помощью математической индукции.

Базис индукции - это 3 изначально добавленные в выпуклую оболочку точки. Необходимо доказать, что в начальном шаге выпуклая оболочка удовлетворяет условию \ref{eq:convex_hull_def}.

Любые 3 точки, не лежащие на одной прямой, являются выпуклой оболочкой, так как они формируют треугольник. Единственное условие, которое необходимо соблюсти - это правильный порядок этих точек. Так как порядок обеспечивается бинарным деревом поиска с предикатом BSTPredicate. Поэтому первые три точки - это валидная выпуклая оболочка.

Пусть теперь для $N$ рассмотренных точек была построена валидная выпуклая оболочка и сейчас рассматривается точка $p_{N+1}$. Как описано выше про добавление точки, может быть два варианта.

Если точка оказалась внутри выпуклой оболочки, то она не может быть добавлена. Заметим, если точка внутри выпуклого многугольника, то она находится справа от любого ребра этого многоугольника. Этот случай уже был показан на рисунке \ref{img:convex_hull_def_2}.

Иначе точка должна быть добавлена. Процесс удаление точек уже был показан на рисунке \ref{img:my_points_deletion_1}. Важное в этом процессе, что он делается по критерию не выполнения $ccw(C, B, A)$, что абсолютно идеинтично критерию выпуклой оболочки в формуле \ref{eq:convex_hull_def}. На рисунке \ref{img:my_proof} показано выполнение условия выпуклой оболочки для новой добавленной точки. Из-за условия удаления точно известно, что после добавления новой точки $p_{N+1}$ удалённые точки и точки $C_1, C_2$ находятся слева от новых рёбер $p_{N+1}, A$ и $B, p_{N+1}$. Осталось показать, что остальные точки также лежат левее этих рёбер.

%TODO: придумать как это правильно доказать.

\begin{figure}[H]
	\centering
	\includegraphics{my_proof_1}
	\caption{Состояние выпуклой оболочки после добавления новой точки}
	\label{img:my_proof}
\end{figure}

\section{Оценка сложности алгоритма} \label{subsect2_4}

%TODO: Написать более строго

Пусть дано множество точек $S$ размера $N$.

Первое, что необходимо определить - это временную сложность алгоритма.

На шаге инициализации алгоритма проводиться поиск трёх экстремальных точек. Это делается за $2 N$ шагов, так как надо сначала найти самые левую и правую точки, а потом найти самую дальнюю от них другую точку.

После чего точки рассматриваются в случайном порядке. Изначально необходимо найти положение точки в бинарном дереве. Эта операция делается за $O(\log h)$, где $h$ - это текущее количество точек в выпуклой оболочке.

%TODO: add ref to C++ std

Если эту точку необходимо добавить, то далее удаляются все точки, которые после добавления точки окажутся внутри выпуклой оболочки. Сложность операции удаления точки может варьироваться для разных сбалансированных двоичных деревьев поиска. В стандарте языка C++ сказано, что амортизированная сложность операции удаления из $std::set$ по итератору является $O(1)$. Поэтому будем считать, что у операции удаления константная сложность.

Во время работы алгоритма максимальное количество удалений не может превышать $N$, так как всего $N$ точек рассматривается. Поэтому эта операция занимает $O(N)$ времени.

Пусть максимальный размер выпуклой оболочки за время работы алгоритма равен $M$. Тогда сложность поиска точек за всё время работы алгоримта равна $O(N \log M)$.

В итоге сложность алгоритма равна $O(2 N + N + N \log M) = O(N \log M)$.

Заметим, что, так как точки добавляются в случайном порядке, средняя сложность алгоритма будет $O(N \log H)$, где $H$ - это количество точек в финальной выпуклой оболочке. Хотя в худшем случае сложность будет равна $O(N \log N)$, что не отличается от самого популярного на данный момент алгоритма Грэхема.

Сколько памяти потребляет предлагаемый алгоритм? Как дополнительную память алгоритм использует только сбалансированное двоичное дерево поиска, поэтому сложность будет равняться $O(M)$. Аналогично временной сложности средняя равна $O(H)$, когда же в худшем случае это $O(N)$.


\section{Выводы} \label{subsect2_5}
