\chapter{Разработка и формализация нового алгоритма построения выпуклой оболочки} \label{chapt2}

\section{Формализация понятия выпуклой оболочки} \label{sect2_1}

\section{Описание алгоритма основанного на использовании бинарного дерева} \label{sect2_2}

\subsection{Основная идея} \label{subsect2_2_1}

Основная идея предлагаемого алгоритма очень похожа на принцип, лежащий в основе инкрементального алгоритма. Мы можем хранить точки в балансированном по высоте двоичном дереве поиска. Главное различие с инкрементальным алгоритмом - точки будут храниться в одном дереве, где точки будут расположены по углу относительно центра выпуклой оболочки.

Чтобы объяснить работу алгоритма нам понадобится уже известный нам предикат $ccw$, определённый в формуле \ref{eq:ccw}. Также необходимо определить понятие экстремальной точки. Экстремальная точка множества $S$ - это точка, которая точно принадлежит выпуклой оболочке $S$.

Пусть дано множество точек $S$ и необходимо найти выпуклую оболочку данного множества.

Первый шаг алгоритма - это нахождение приближенного центра, с помощью которого будут отсортированы в дереве точки. Это можно сделать посчитав среднее арифметическое трёх экстремальных точек. Это отличная аппроксимация центра для наших целей. Первые 2 экстремальные точки -  это самая левая $A$ и правая $B$ точки множества $S$. Третья точка - это наиболее удалённая от линии $A, B$ точка $C$.

Пример таких точек показан на рисунке \ref{img:my_extreme_points}. Точка $D$ - это приближённый центр выпуклой оболочки, который мы искали.

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_extreme_points_1}]{%
			\includegraphics[width=0.4\linewidth]{my_extreme_points_1}}
		\hfill
		\subbottom[\label{img:my_extreme_points_2}]{%
			\includegraphics[width=0.4\linewidth]{my_extreme_points_2}}
		\hfill
	}
	\caption{Нахождение приближённого центра выпуклой оболочки}
	\label{img:my_extreme_points}
\end{figure}

После нахождения центра мы добавляем точки $A, B, C$ в наше дерево поиска. Остальные точки будут добавлены в случайном порядке.

Пусть мы уже построили дерево поиска, в котором содержится наша выпуклая оболочка, отсортированная по углу относительно центра $D$, найденнного ранее. Теперь необходимо добавить новую точку $A$.

Первое, что необходимо найти - это две точки $L$ и $R$. Точки $L$, $R$ - это точки слева и справа соответственно от $A$ по углу относительно центра $D$.

%TODO: Проверить, что я точно написал правду для точек на одной прямой

После чего может быть 2 случая. Если $ccw(L, R, A)$ не выполняется, то новая точка $A$ не должна быть частью выпуклой оболочки и может быть пропущена. Этот случай показан на рисунке \ref{img:my_point_cases_1}. Иначе точки должна быть частью выпуклой оболочки и мы продолжим добавлять её. Это показано на рисунке \ref{img:my_point_cases_2}.

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_point_cases_1}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_1}}
		\hfill
		\subbottom[\label{img:my_point_cases_2}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_2}}
		\hfill
	}
	\caption{Добавление новой точки в выпуклую оболочку}
	\label{img:my_point_cases}
\end{figure}

Итак, мы определили, что точка $A$ должна быть на выпуклой оболочке. Теперь необходимо удалить точки, которые будут внутри оболочки после добавления точки $A$. Это делается с помощью итерации по точкам вправо (аналогичный алгоритм должен быть выполнен для левой стороны) от новой точки. Чтобы определить должна ли точка быть удалена или нет мы будем использовать подход, похожий на тот, который используется в алгоритме Грэхема. Каждые два смежных ребра выпуклой оболочки должны лежать против часовой стрелки.

Пусть следующая точка, которая рассматривается на удаление - это $B$, а точка следующая после неё $C$. Как сказано выше каждые два смежных ребра должны лежать против часовой стрелки. Это очень легко проверить с помощью предиката $ccw$. Если $ccw(C, B, A)$ тогда $B$ не должна быть удалена и мы должны прекратить удаление точек в эту сторону, потому что все точки после $B$ уже удовлетворяют условию выпуклой оболочки. Иначе мы должны удалить точку $B$ и рассмотреть точку $C$ как следующую. Этот процесс показан на рисунках \ref{img:my_points_deletion_1} и \ref{img:my_points_deletion_2}.

%TODO: Добавить описание удаления по рисункам

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_points_deletion_1_1}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_3}}
		\hfill
		\subbottom[\label{img:my_points_deletion_1_2}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_4}}
		\hfill
	}
	\caption{Удаление точек, которые оказались внутри выпуклой оболочки}
	\label{img:my_points_deletion_1}
\end{figure}

\begin{figure}[H]
	{\centering
		\hfill
		\subbottom[\label{img:my_points_deletion_2_1}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_5}}
		\hfill
		\subbottom[\label{img:my_points_deletion_2_2}]{%
			\includegraphics[width=0.4\linewidth]{my_add_point_6}}
		\hfill
	}
	\caption{Критерий завершения удаления точек}
	\label{img:my_points_deletion_2}
\end{figure}

Как видно этот процесс очень схож с процессом добавления точек в инкрментальном алгоритме. Различия небольшие, но они позволяют быстрее добавлять точки в выпуклую оболочку.

Блок-схема всего алгоритма показана на рисунке \ref{img:my_algo}.

%TODO: Исправить изображение (смазано, обрезано)

\begin{figure}[H] 
	\centering
	\includegraphics{my_algo}
	\caption{Блок-схема работы предлагаемого алгоритма}
	\label{img:my_algo}
\end{figure}

\subsection{Детали реализации} \label{subsect2_2_2}

\section{Доказательство корректности работы алгоритма} \label{subsect2_3}

\section{Оценка быстродействия предлагаемого алгоритма} \label{subsect2_4}


